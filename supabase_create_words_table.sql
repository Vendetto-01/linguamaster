CREATE TABLE public.words (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  word TEXT NOT NULL,
  part_of_speech TEXT NOT NULL,
  definition TEXT NOT NULL,
  difficulty_level TEXT NOT NULL,
  example_sentence TEXT NOT NULL,
  option_a TEXT NOT NULL,
  option_b TEXT NOT NULL,
  option_c TEXT NOT NULL,
  option_d TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  update_note TEXT NULL,
  placeholder_1 TEXT NULL, -- Or another appropriate type like JSONB, INT etc.
  placeholder_2 TEXT NULL  -- Or another appropriate type
);

-- Optional: Enable Row Level Security (RLS) if you plan to access it directly from the frontend
-- For an admin panel backend like this, direct frontend access to Supabase might not be needed
-- if all interactions go through your backend API, which uses the service_role key.
-- However, if you might add direct Supabase calls from the frontend later, RLS is crucial.

-- Example of enabling RLS (adjust policies as needed):
-- ALTER TABLE public.words ENABLE ROW LEVEL SECURITY;

-- Example policy: Allow public read access (if needed for some reason)
-- CREATE POLICY "Allow public read access" ON public.words
-- FOR SELECT USING (true);

-- Example policy: Allow authenticated users to insert (if your backend uses user-specific keys, not service_role)
-- CREATE POLICY "Allow authenticated insert" ON public.words
-- FOR INSERT TO authenticated WITH CHECK (true);

-- Example policy: Allow users to update their own records (if you add a user_id column)
-- CREATE POLICY "Allow individual update" ON public.words
-- FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- For the current backend setup (using service_role key), RLS policies for direct client access
-- are less critical as the service_role bypasses RLS. But it's good practice to be aware of RLS.

-- It's also good practice to create a trigger to automatically update `updated_at`
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_words_updated
  BEFORE UPDATE ON public.words
  FOR EACH ROW
  EXECUTE PROCEDURE public.handle_updated_at();

COMMENT ON TABLE public.words IS 'Stores vocabulary words with definitions, examples, and quiz options.';
COMMENT ON COLUMN public.words.definition IS 'Dictionary-style definitions, potentially bullet points as a single string.';
COMMENT ON COLUMN public.words.difficulty_level IS 'e.g., A1, A2, B1, C1, C2';
COMMENT ON COLUMN public.words.option_a IS 'Correct multiple-choice answer.';
COMMENT ON COLUMN public.words.update_note IS 'Most recent note about an update, if any.';